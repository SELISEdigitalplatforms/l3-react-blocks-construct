# Example: How to use the SonarQube JS/TS workflow in your CI/CD pipeline
# Pattern matches the .NET workflow - load variables in init job, pass as inputs

name: CI/CD - Dev Environment

on:
  push:
    branches:
      - cicd-test
  pull_request:
    branches:
      - cicd-test
    types:
      - opened
      - reopened
      - synchronize

env:
  # ========================================
  # Environment-Specific Configuration
  # (Different for each environment)
  # ========================================
  ENVIRONMENT: "dev"
  CLUSTER_NAME: "aks-blocks-dev" # TODO: Set your dev cluster name

  # ========================================
  # Quality Checks
  # ========================================
  RUN_TESTS: "false" # Usually disabled in dev for speed
  RUN_SONARQUBE: "false" # Enable for testing the new dotnet-coverage integration
  RUN_SCA_SCAN: "true" # Enable SCA Scan

  # ========================================
  # Tag Stategy for Build and GitOps
  # ========================================
  TAG_STRATEGY: "commit" # Options: "both" (default), "semantic", "commit"

  # ========================================
  # Shared Configuration Loading
  # ========================================
  LOAD_CUSTOM_VARS:
    "true" # Load shared config from .github/variables/vars.env
    # Set to 'false' only if you don't have vars.env

concurrency:
  group: ${{ github.ref_name }}
  cancel-in-progress: true
jobs:
  # ==============================================
  # Initialize configuration (load from vars.env)
  # ==============================================
  initialization:
    runs-on: ubuntu-latest
    outputs:
      cluster_name: ${{ steps.config.outputs.cluster_name }}
      environment: ${{ steps.config.outputs.environment }}
      load_custom_vars: ${{ steps.config.outputs.load_custom_vars }}
      project_name: ${{ steps.config.outputs.project_name }}
      project_version: ${{ steps.config.outputs.project_version }}
      run_tests: ${{ steps.config.outputs.run_tests }}
      run_sonarqube: ${{ steps.config.outputs.run_sonarqube }}
      run_sca_scan: ${{ steps.config.outputs.run_sca_scan }}
      service_name: ${{ steps.config.outputs.service_name }} # e.g., your service name
      service_type: ${{ steps.config.outputs.service_type }} # e.g., webclient, webservice, winservice
      sonarqube_host: ${{ steps.config.outputs.sonarqube_host }} # e.g., https://code.selise.biz
      sonar_project_key: ${{ steps.config.outputs.sonar_project_key }} # e.g., your SonarQube project key
      sonar_organization: ${{ steps.config.outputs.sonar_organization }} # e.g., your SonarQube org
      solution_name: ${{ steps.config.outputs.solution_name }} # e.g., YourSolution.sln for .NET
      tag_strategy: ${{ steps.config.outputs.tag_strategy }} # e.g., commit, semantic
      working_directory: ${{ steps.config.outputs.working_directory }} # e.g., ./src. Used for SonarQube
      version: ${{ steps.config.outputs.version }} # Version suffix based on environment
      dockerfile_path: ${{ steps.config.outputs.dockerfile_path }} # Path to Dockerfile
      win_dockerfile_path: ${{ steps.config.outputs.win_dockerfile_path }} # Path to Window/Console service Dockerfile
      dependency_track_host: ${{ steps.config.outputs.dependency_track_host }} # e.g., api-dt.seliseblocks.com
      dependency_track_frontend_url: ${{ steps.config.outputs.dependency_track_frontend_url }} # e.g., sca.seliseblocks.com
      has_submodules: ${{ steps.config.outputs.has_submodules }}
      package_manager: ${{ steps.config.outputs.package_manager }}
      node_version: ${{ steps.config.outputs.node_version }}

    steps:
      - uses: actions/checkout@v4

      # Load shared variables first (if enabled)
      - name: Load Shared Configuration
        if: env.LOAD_CUSTOM_VARS == 'true'
        uses: ./.github/actions/setvars
        with:
          varFilePath: ./.github/variables/

      - name: Set Configuration Outputs
        id: config
        run: |
          # From workflow env (environment-specific)
          echo "run_tests=${{ env.RUN_TESTS }}" >> $GITHUB_OUTPUT
          echo "run_sonarqube=${{ env.RUN_SONARQUBE }}" >> $GITHUB_OUTPUT
          echo "environment=${{ env.ENVIRONMENT }}" >> $GITHUB_OUTPUT
          echo "cluster_name=${{ env.CLUSTER_NAME }}" >> $GITHUB_OUTPUT
          echo "load_custom_vars=${{ env.LOAD_CUSTOM_VARS }}" >> $GITHUB_OUTPUT
          echo "tag_strategy=${{ env.TAG_STRATEGY }}" >> $GITHUB_OUTPUT
          echo "run_sca_scan=${{ env.RUN_SCA_SCAN }}" >> $GITHUB_OUTPUT

          # From vars.env (if loaded) or fallback to defaults
          echo "dockerfile_path=${DOCKERFILE:-./Dockerfile}" >> $GITHUB_OUTPUT
          echo "win_dockerfile_path=${WIN_DOCKERFILE:-./win.Dockerfile}" >> $GITHUB_OUTPUT

          # From vars.env (if loaded) or fallback to defaults
          echo "service_name=${SERVICE_NAME:-github.event.repository.name}" >> $GITHUB_OUTPUT
          echo "service_type=${SERVICE_TYPE:-}" >> $GITHUB_OUTPUT
          echo "sonarqube_host=${SONARQUBE_HOST:-}" >> $GITHUB_OUTPUT
          echo "has_submodules=${HAS_SUBMODULES:-true}" >> $GITHUB_OUTPUT
          echo "package_manager=${PACKAGE_MANAGER:-npm}" >> $GITHUB_OUTPUT
          echo "node_version=${NODE_VERSION:-21}" >> $GITHUB_OUTPUT

          # Project configuration for SCA Scan
          echo "project_name=${PROJECT_NAME:-${{ github.event.repository.name }}}" >> $GITHUB_OUTPUT
          echo "project_version=${PROJECT_VERSION:-${{ github.ref_name }}}" >> $GITHUB_OUTPUT
          echo "dependency_track_host=${DEPENDENCY_TRACK_HOST:-api-dt.seliseblocks.com}" >> $GITHUB_OUTPUT
          echo "dependency_track_frontend_url=${DEPENDENCY_TRACK_FRONTEND_URL:-sca.seliseblocks.com}" >> $GITHUB_OUTPUT

          # SonarQube specific configurations (map from vars.env names)
          echo "sonar_project_key=${SONAR_KEY:-}" >> $GITHUB_OUTPUT
          echo "sonar_organization=${AUTHOR:-}" >> $GITHUB_OUTPUT
          echo "solution_name=${SOLUTION_NAME:-YourSolution.sln}" >> $GITHUB_OUTPUT
          echo "working_directory=${WORKING_DIRECTORY:-./src}" >> $GITHUB_OUTPUT

          # Version based on environment (from versions.env)
          ENVIRONMENT="${{ env.ENVIRONMENT }}"
          case "$ENVIRONMENT" in
            "dev")
              VERSION="${DEV_VERSION:-}"
              ;;
            "stg")
              VERSION="${STAGE_VERSION:-}"
              ;;
            "prod")
              VERSION="${PROD_VERSION:-}"
              ;;
            "uat")
              VERSION="${UAT_VERSION:-}"
              ;;
            *)
              VERSION=""
              ;;
          esac
          echo "version=${VERSION}" >> $GITHUB_OUTPUT

          echo "### ðŸ”§ Pipeline Configuration" >> $GITHUB_STEP_SUMMARY
          echo "- **Service**: ${SERVICE_NAME:-'Not set'}" >> $GITHUB_STEP_SUMMARY
          echo "- **Version Suffix**: ${VERSION:-'None'}" >> $GITHUB_STEP_SUMMARY
          echo "- **Type**: ${SERVICE_TYPE:-'Not set'}" >> $GITHUB_STEP_SUMMARY
          echo "- **Environment**: ${{ env.ENVIRONMENT }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Image Tag Strategy**: ${{ env.TAG_STRATEGY }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Cluster**: ${{ env.CLUSTER_NAME }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Tests Enabled**: ${{ env.RUN_TESTS }}" >> $GITHUB_STEP_SUMMARY
          echo "- **SonarQube Enabled**: ${{ env.RUN_SONARQUBE }}" >> $GITHUB_STEP_SUMMARY
          echo "- **SCA Scan Enabled**: ${{ env.RUN_SCA_SCAN }}" >> $GITHUB_STEP_SUMMARY

  # # Run tests and checks on PRs only (optional)
  # pr-checks:
  #     if: github.event_name == 'pull_request' && needs.initialization.outputs.run_tests == 'true'
  #     needs: [initialization]
  #     uses: SELISEdigitalplatforms/l0-yml-devops-workflow/.github/workflows/test.yml@main
  #     with:
  #         SERVICE_NAME: ${{ needs.initialization.outputs.service_name }}
  #         LOAD_CUSTOM_VARS: ${{ needs.initialization.outputs.load_custom_vars == 'true' }}
  #     secrets:
  #         SELISE_GITHUB_PAT: ${{ secrets.SELISE_GITHUB_PAT }}

  # ==============================================
  # SonarQube Analysis - Pass variables as inputs
  # ==============================================
  sonarqube:
    if: needs.initialization.outputs.run_sonarqube == 'true'
    needs: [initialization]
    uses: ./.github/workflows/sonarqube-js.yml
    with:
      # Required
      SONARQUBE_HOST: ${{ needs.initialization.outputs.sonarqube_host }}

      # Optional - General Configuration
      SERVICE_NAME: ${{ needs.initialization.outputs.service_name }}
      NODE_VERSION: ${{ needs.initialization.outputs.node_version }}
      JAVA_VERSION: "17"

      # Optional - Package Manager
      PACKAGE_MANAGER: ${{ needs.initialization.outputs.package_manager }}
      INSTALL_COMMAND: "ci"
      TEST_COMMAND: "test -- --coverage"

      # Optional - SonarQube Configuration
      SONAR_PROJECT_KEY: ${{ needs.initialization.outputs.sonar_project_key }}
      SONAR_SOURCES: "src"
      SONAR_TESTS: "src"

      # Optional - Coverage Exclusions
      COVERAGE_EXCLUSIONS: "**/*.test.ts,**/*.test.tsx,**/*.spec.ts,**/*.spec.tsx,**/node_modules/**,**/dist/**,**/build/**"

      # Optional - Feature Flags
      HAS_SUBMODULES: ${{ needs.initialization.outputs.has_submodules == 'true' }}
      SKIP_QUALITY_GATE: false

    secrets:
      SONAR_TOKEN: ${{ secrets.SONAR_TOKEN_GLOBAL }}
      SELISE_GITHUB_PAT: ${{ secrets.SELISE_GITHUB_PAT }}

  # ==============================================
  # ALTERNATIVE: Simple Direct Passing (No Init Job)
  # ==============================================
  # If you don't need vars.env, you can pass values directly:
  #
  # jobs:
  #   sonarqube:
  #     uses: ./.github/workflows/sonarqube-js-recommended.yml
  #     with:
  #       SONARQUBE_HOST: "https://code.selise.biz"
  #       SERVICE_NAME: "my-service"
  #     secrets:
  #       SONAR_TOKEN: ${{ secrets.SONAR_TOKEN_GLOBAL }}

  # ==============================================
  # SCA Scan - Pass variables as inputs
  # ==============================================
  sca-scan:
    if: needs.initialization.outputs.run_sca_scan == 'true'
    needs: [initialization]
    uses: ./.github/workflows/sca-scan-js.yml
    with:
      # Project Configuration
      PROJECT_NAME: ${{ needs.initialization.outputs.project_name }}
      PROJECT_VERSION: ${{ needs.initialization.outputs.project_version }}

      # Node Configuration
      NODE_VERSION: ${{ needs.initialization.outputs.node_version }}
      PACKAGE_MANAGER: ${{ needs.initialization.outputs.package_manager }}
      INSTALL_COMMAND: "ci"
      # SBOM_TOOL: "cdxgen" # e.g. cdxgen(default), cyclonedx-npm. Better use cdxgen if unsure.
      # USE_DOCKER: true

      # Dependency-Track Configuration (optional)
      DEPENDENCY_TRACK_HOST: ${{ needs.initialization.outputs.dependency_track_host }}
      DEPENDENCY_TRACK_FRONTEND_URL: "${{ needs.initialization.outputs.dependency_track_frontend_url }}"
      AUTO_CREATE_PROJECT: true
      ARTIFACT_RETENTION_DAYS: 1

      # Optional Features
      HAS_SUBMODULES: ${{ needs.initialization.outputs.has_submodules == 'true' }}

    secrets:
      DEPENDENCY_TRACK_API_KEY: ${{ secrets.DEPENDENCY_TRACK_API_KEY }}
      SELISE_GITHUB_PAT: ${{ secrets.SELISE_GITHUB_PAT }}
  # ==============================================
  # ALTERNATIVE: Simple Direct Passing (No Init Job)
  # ==============================================
  # If you don't need vars.env, you can pass values directly:
  #
  # jobs:
  #   sca-scan:
  #     uses: ./.github/workflows/sca-scan-js-recommended.yml
  #     with:
  #       PROJECT_NAME: "my-project"
  #       DEPENDENCY_TRACK_HOST: "api-dt.seliseblocks.com"
  #     secrets:
  #       DEPENDENCY_TRACK_API_KEY: ${{ secrets.DEPENDENCY_TRACK_API_KEY }}

  # # Build and push image
  # build:
  #   needs: [initialization, sonarqube]
  #   if: ${{ github.event_name == 'push' && (success() || needs.sonarqube.result == 'skipped' ) }}
  #   uses: ./.github/workflows/build-push.yml
  #   with:
  #     SERVICE_NAME: ${{ needs.initialization.outputs.service_name }}
  #     # SERVICE_TYPE: ${{ needs.initialization.outputs.service_type }}
  #     SERVICE_TYPE: "webclient" # e.g., webclient, webservice, winservice
  #     ENVIRONMENT: ${{ needs.initialization.outputs.environment }}
  #     TAG_STRATEGY: ${{ needs.initialization.outputs.tag_strategy }} # Options: "both" (default), "semantic", "commit"
  #     DOCKERFILE_PATH: ${{ needs.initialization.outputs.dockerfile_path }}
  #     VERSION: ${{ needs.initialization.outputs.version }} # Optional: Comment out to skip version suffix
  #     BUILD_ARGS: |
  #       ci_build=dev
  #   secrets:
  #     AZURE_CREDENTIALS: ${{ secrets.AZURE_AKS_BLOCKS_CREDENTIALS }}
  #     AZURE_CONTAINER_REGISTRY: ${{ secrets.AZURE_BLOCKS_CONTAINER_REGISTRY }}
  #     ACR_RESOURCE_GROUP: ${{ secrets.ClUSTER_AKS_BLOCKS_RESOURCE_GROUP }}
  #     SELISE_GITHUB_PAT: ${{ secrets.SELISE_GITHUB_PAT }}

  # # Update GitOps repository
  # update-gitops:
  #   needs: [initialization, build]
  #   if: |
  #     github.event_name == 'push' &&
  #     always() &&
  #     needs.initialization.result == 'success' &&
  #     needs.build.result == 'success'
  #   uses: ./.github/workflows/update-gitops.yml
  #   with:
  #     SERVICE_NAME: ${{ needs.initialization.outputs.service_name }}
  #     # SERVICE_TYPE: ${{ needs.initialization.outputs.service_type }}
  #     SERVICE_TYPE: "webclient" # Match the service type from build job
  #     ENVIRONMENT: ${{ needs.initialization.outputs.environment }}
  #     VERSION: ${{ needs.initialization.outputs.version }} # Pass version for proper file naming
  #     IMAGE_TAG: ${{ needs.build.outputs.image_tag }}
  #     COMMIT_TAG: ${{ needs.build.outputs.commit_tag }}
  #     SEMANTIC_TAG: ${{ needs.build.outputs.semantic_tag }}
  #     TAG_STRATEGY: ${{ needs.initialization.outputs.tag_strategy }} # Options: "commit" (default), "semantic", or "primary"
  #     CLUSTER_NAME: ${{ needs.initialization.outputs.cluster_name }}
  #     # GITOPS_BRANCH: "main"
  #   secrets:
  #     SELISE_GITHUB_PAT: ${{ secrets.SELISE_GITHUB_PAT }}
  #     AZURE_CONTAINER_REGISTRY: ${{ secrets.AZURE_BLOCKS_CONTAINER_REGISTRY }}
